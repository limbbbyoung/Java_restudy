package day4;

public class Sample2 {
	// 객체를 넘기는 방법을 위한 객체 변수 생성
	int a;
	/* 가장 간단하지만 많은 것을 설명해 주는 다음의 메소드를 보자.
	 */
	int sum(int a, int b) {
		return a+b;
	}
	// 위 메소드의 의미는 다음과 같이 정의된다.
	// "sum 메소드는 입력값으로 두개의 값(int 자료형 a, int 자료형 b)을 받으며
	// 리턴값은 두 개의 입력값을 더한 값(int 자료형)이다."
	// 여기서 return은 메소드의 결과 값을 돌려주는 명령어이다. 직접 위의 메소드를 
	// 만들어 보고 사용해 보자.
	
	/* sum 메소드의 입출력 자료형은 다음과 같다
	 * -입력 값 - int 자료형 a, int 자료형 b
	 * -리턴 값 - int 자료형
	 * sum 메소드는 두 개의 입력값을 받아서 서로 더한 결과값을 
	 * 돌려주는 메소드이다. 위처럼 입력값과 리턴값이 있는 메소드는
	 * 다음처럼 사용된다.
	 * 리턴값받을변수 = 객체.메소드명(입력인수1, 입력인수2, ...)
	 * 
	 * Sample sample = new Sample();
	 * int result = sample.sum(3, 4);
	 * 위에서 보듯이 sample.sum(3, 4) 호출 후 리턴값을 저장하는 
	 * result의 자료형은 int로 해야만 한다. 왜냐하면 sum메소드의 
	 * 리턴타입이 int로 되어 있기 때문이다.sum메소드의 리턴타입은
	 * int sum(int a, int b) { ... 에서 보듯이 
	 * 메소드명(sum) 바로 좌측에 표기하도록 되어 있다.
	 * 
	 * 입력값이 없는 메소드 
	 * 입력값이 없는 메소드가 존재할까?당연히 있음
	 */
	String say() {
		return "Hi";
	}
	/* say메소드의 입출력 자료형은 다음과 같다.
	 * - 입력값 : 없음
	 * - 리턴값 : String 자료형
	 * say라는 이름의 메소드를 만들었다. 하지만 입력 인수부분을 
	 * 나타내는 괄호 안이 비어있다.
	 */
	
	 // 리턴값이 없는 메소드 
	 // 리턴값이 없는 메소드 역시 존재한다.
	void sum2(int a, int b) {
		System.out.println(a + "과 "+b+"의 합은 "+ 
	 (a+b)+"입니다.");
	}
	/* 위 sum 메소드의 입출력 자료형은 다음과 같다
	 * -입력 값 : int 자료형 a, int 자료형 b 
	 * -리턴 값 : void(없음)
	 *  리턴값이 없는 메소드는 명시적으로 리턴타입 부분에 void 라고 표기한다.
	 *  리턴값이 없는 메소드는 값이 없기 때문에 다음과 같이 사용한다.(아래 main안에 있음)
	 */
	
	// 입력값도 리턴값도 없는 메소드 
	void say2() {
		System.out.println("Hi");
	}
	/* 위 메소드의 입출력 자료형은 다음과 같다.
	 * - 입력값 : 없음
	 * - 리턴값 : void(없음)
	 * 입력 값을 받는 곳도 없고 return문도 없으니 입력값도 
	 * 리턴값도 없는 메소드이다.
	 */
	
	// return의 또 다른 쓰임새 예시에 쓰일 메소드
	void sayNick(String nick) {
		if("fool".equals(nick)) {
			return;
		}
		System.out.println("나의 별명은 "+ nick + " 입니다.");
	}
	
	// 메소드 내에서 선언된 변수의 효력 범위 예시에 쓰일 메소드
	int varTest(int a) {
		a++;
		return a;
	}
	
	void varTest2(Sample2 sample) {
		sample.a++;
	}

	public static void main(String[] args) {
		// 메소드(Method)
		/* 다른 프로그래밍 언어에는 함수라는 것이 별도로 존재한다.
		 * 하지만 자바는 클래스를 떠나 존재하는 것은 있을 수 없기 때문에
		 * 자바의 함수는 따로 존재하지 않고 클래스 내에 존재한다.
		 * 
		 * 자바는 이러한 클래스 내의 함수를 메소드라고 부른다.
		 * * 보통 함수와 메소드가 공존하는 언어(예:파이썬)에서는 
		 * 두 개를 구분하여 말하기도 하지만 자바는 보통 메소드와 함수를 
		 * 구분하여 말하지 않는다. 다만 자바에서 사용되는 함수의 정확한 명칭은 메소드이다.
		 * 
		 * 여기까지 공부해 오면서 메소드에 대해서 이미 알아 보았지만 
		 * 이번 장에서는 좀 더 자세하게 알아보자.
		 * 
		 * 메소드를 설명하기 전에 믹서기를 생각해보자. 우리는 믹서기에 과일을 넣는다.
		 * 그리고 믹서를 이용해서 과일을 갈아서 과일 쥬스를 만들어 낸다. 
		 * 우리가 믹서기에 넣는 과일은 입력이 되고 과일 쥬스는 그 출력(리턴값)이 된다.
		 * 
		 * 그렇다면 믹서기는 무엇인가?
		 * 믹서기가 바로 우리가 여기서 알고자 하는 메소드이다.
		 * 입력을 가지고 어떤 일을 수행한 다음에 결과무을 내어놓는 것,
		 * 이것이 메소드가 하는 일이다.
		 */
		
		/* 메소드를 사용하는 이유?
		 * 가끔 프로그래밍을 하다 보면 똑같은 내용을 자신이 반복해서 적고 있는 것을 
		 * 발견할 때가 있다. 이 때가 바로 메소드가 필요한 때이다.
		 * 여러 번 반복해서 사용된다는 것은 언제고 또 다시 사용할 만한 
		 * 가치가 있는 부분이라는 뜻이다. 즉, 이러한 경우 
		 * 이것을 한 뭉치로 묶어서 "어떤 입력값을 주었을 때 
		 * 어떤 리턴값을 돌려준다"라는 식의 메소드를 작성하는 것이 
		 * 현명한 일일 것이다.
		 * 
		 * 가장 간단하지만 많은 것을 설명해 주는 다음의 메소드를 보자.
		 */
		
		int a = 3;
		int b = 4;
		Sample2 sample = new Sample2();
		int c = sample.sum(a, b);
		System.out.println(c);
		// 위 코드는 sum메소드에 3, 4라는 입력값을 전달하여 
		// 7이라는 값을 돌려받는 예제이다. 실행해보면 
		// 7이라는 값이 출력되는 것을 확인할 수 있다.
		
		/* Sample2 클래스의 main메소드에서 
		 * Sample2 sample = new Sample()처럼
		 * 자기 자신의 객체를 생성했다. 이것은 당연히 가능한 
		 * 코드이고 작성한 클래스를 단독으로 실행시켜
		 * 테스트할 때 자주 사용하는 방법이다. 
		 */
		
		/* 매개변수와 인수
		 * 매개변수(parameter)와 인수(arguments)는 
		 * 혼용해서 사용되는 헷갈리는 용어이므로 잘 기억해 두자.
		 * 매개변수는 메소드에 입력으로 전달된 값을 받는 변수를 
		 * 의미하고 인수는 메소드를 호출할 때 전달하는 입력값을 의미한다.
		 */
		
		/* 메소드의 입력값과 리턴값
		 * 메소드는 들어온 입력값을 가지고 어떤 처리를 하여 적절한
		 * 리턴값을 돌려주는 블랙박스와 같다.
		 * 입력값 --> 메소드(블랙박스) --> 리턴값
		 * 메소드에 들어오는 입력값과 리턴값에 대해서 자세히 알아보도록 하자.
		 * 
		 * 메소드의 구조 
		 * 자바의 메소드 구조는 아래와 같다
		 * 리턴자료형 메소드명(입력자료형1 매개변수1, 입력자료형2 매개변수2, ...) {
		 * ...
		 * return 리턴값; // 리턴자료형이 void인 경우에는 return문이 필요없다.
		 *  } 
		 *  리턴자료형은 메소드 수행 후 돌려줄 값의 자료형을 의미한다.
		 *  메소드의 리턴값은 return이라는 명령을 사용한다.
		 *  메소드는 입출력 유무에 따라 다음과 같이 4가지로 분류할 수 있다.
		 *  -입력과 출력이 모두 있는 메소드 
		 *  -입력과 출력이 모두 없는 메소드 
		 *  -입력은 없고 출력은 있는 메소드 
		 *  -입력은 있고 출력은 없는 메소드
		 *  
		 *  일반적인 메소드 
		 *  입력 값이 있고 리턴값이 있는 메소드가 일반적인 메소드이다.
		 *  일반적인 메소드의 전형적인 예
		 */
		
		// say메소드 사용
		String a2 = sample.say();
		System.out.println(a2);
		/* say메소드를 쓰기 위해서는 say()처럼 괄호 안에
		 * 아무런 값도 넣지 않고 써야한다.
		 * say메소드는 입력값은 없지만 리턴값으로 'Hi'라는 
		 * 문자열을 돌려준다. 따라서 String a = sample.say() 처럼
		 * 하면 a에는 "Hi"라는 문자열이 대입될 것이다.
		 * 즉, 입력값이 없고 리턴값만 있는 메소드는 다음과 같이 사용된다.
		 * 리턴값받을변수 = 객체.메소드명()
		 */
		
		// 리턴값이 없는 메소드 예시
		sample.sum2(a, b);
		// 리턴값이 없는 메소드는 다음과 같이 사용된다.
		// 객체.메소드명(입력인수1, 입력인수2, ..)
		
		// 입력값도 리턴값도 없는 메소드 예시 
		sample.say2();
		
		/* return의 또 다른 쓰임새
		 * 특별한 경우에 메소드를 빠져나가기를 원할 때 return을 
		 * 단독으로 사용하여 메소드를 즉시 빠져나갈 수 있다.
		 */
		sample.sayNick("angle");
		sample.sayNick("fool"); // 출력되지 않음
		// 메소드의 리턴값은 오로지 return문에 의해서만 생성된다.
		// *return문만을 써서 메소드르 빠져나가는 이 방법은 리턴 
		// 자료형이 void인 메소드에만 해당된다. 리턴자료형이 명시되어 있는 
		// 메소드에서 return문만 작성하면 컴파일 오류가 발생한다.
		
		/* 메소드 내에서 선언된 변수의 효력 범위
		 * 메소드안에서 사용하는 변수의 이름을 메소드 밖에서 사용한 이름과 
		 * 동일하게 사용한다면 어떻게 될까?
		 */
		int a3 = 1;
		a3 = sample.varTest(a3);
		System.out.println(a3);
		/* 먼저 main 메소드에서 a라는 int 자료형의 변수를 생성하고 1을 대입했다.
		 * 그리고 varTest메소드를 입력 값 a를 주어 호출했다.
		 * 그 다음에 a의 값을 출력하게 하였다. 당연히 varTest메서드에서 
		 * a의 값을 1만큼 증가시켰으니 2가 출력되어야 할 것 같지만
		 * 프로그램을 실행시켜보면 1이라는 결과 값이 나온다.
		 * 
		 * 그 이유는 메소드 내에서 사용되는 변수는 메소드 안에서만 
		 * 쓰여지는 변수이기 때문이다. 즉, public void varTest(int a){라는
		 * 문장에서 입력 인수를 뜻하는 변수 a는 메소드 안에서만 쓰이는 
		 * 변수이지 메소드 밖의 변수 a가 아니라는 말이다.
		 * 
		 * 즉, 메소드에서 쓰이는 변수는 메소드 밖의 변수 이름들과는 전혀 상관 없다.
		 * 그래서 이렇게 메소드 내에서만 쓰이는 변수를 로컬 변수(locaa variable)라고도 말한다.
		 * 
		 * 만약 varTest 입력값이 int자료형이 아닌 객체였다면 얘기가 다르다.
		 * 객체를 메소드의 입력으로 넘기고 메소드가 객체의 속성값(객체변수 값)을 
		 * 변경한다면 메소드 수행 이후에도 객체는 변경된 속성값을 유지한다.
		 * 이런한 차이가 나는 이유는 메소드에 전달하는 입력 자료형의 형태 때문인데 
		 * 메소드에 값을 전달하느냐 아니면 객체를 전달하느냐에 따라 차이가 난다.
		 */
		
		// 그렇다면 varTest라는 메소드를 이용해서 메소드 외부의 a를 1만큼 
		// 증가시킬 수 있는 방법은 없을까?
		// 위에서 변경함
		
	    // 객체를 넘기는 방법에 대해서
	    sample.a = 1;
	    sample.varTest2(sample);
	    System.out.println(sample.a);

	}

}
